# V2.2.0: Multicore Implementation

## Analysis

### Thread Safety Assessment

**creature.step() reads from others:**
- pos (position)
- alive (bool)
- species (immutable)
- creature_id (immutable)

**creature.step() writes:**
- Only self.* (own state)
- Returns 'dead' or 'reproduce' or None

**Verdict:** Embarrassingly parallel with position snapshot.

## Strategy: Snapshot + Parallel + Merge

```
┌─────────────────────────────────────────────────────────────────┐
│                     MAIN THREAD                                 │
├─────────────────────────────────────────────────────────────────┤
│  1. SNAPSHOT PHASE (sequential, fast)                           │
│     - Copy all creature positions to read-only array            │
│     - Copy alive status array                                   │
│                                                                 │
│  2. PARALLEL PHASE (ThreadPoolExecutor)                         │
│     - Each creature.step() reads from snapshot                  │
│     - Each creature writes only to self                         │
│     - Returns result ('dead', 'reproduce', None)                │
│                                                                 │
│  3. MERGE PHASE (sequential)                                    │
│     - Process deaths                                            │
│     - Process reproductions                                     │
│     - Update shared state (evo tree, logs)                      │
└─────────────────────────────────────────────────────────────────┘
```

## Implementation

### Phase 1: Add Snapshot Support to Creature

```python
# In creature.py
class Creature:
    # Add snapshot holder
    _world_snapshot = None  # Set before parallel step
    
    def step_with_snapshot(self, snapshot, audio_amp, silence_frames, audio_system):
        """Step using pre-computed world snapshot instead of live creature list."""
        # Use snapshot for sensing instead of live data
        self.sense_nearby_creatures_from_snapshot(snapshot)
        # ... rest of step logic
```

### Phase 2: Create World Snapshot

```python
# In creature_manager.py
@dataclass
class WorldSnapshot:
    """Read-only snapshot of world state for parallel creature stepping."""
    positions: np.ndarray      # (n_creatures, 2) 
    alive: np.ndarray          # (n_creatures,) bool
    species_names: List[str]   # For each creature
    creature_ids: List[str]    # For each creature
    can_hunt_matrix: np.ndarray  # (n, n) bool - precomputed
    
    @classmethod
    def from_creatures(cls, creatures: List[Creature]) -> 'WorldSnapshot':
        n = len(creatures)
        snapshot = cls(
            positions=np.array([c.pos for c in creatures]),
            alive=np.array([c.alive for c in creatures]),
            species_names=[c.species.name for c in creatures],
            creature_ids=[c.creature_id for c in creatures],
            can_hunt_matrix=np.zeros((n, n), dtype=bool)
        )
        # Precompute hunt relationships
        for i, c1 in enumerate(creatures):
            for j, c2 in enumerate(creatures):
                snapshot.can_hunt_matrix[i, j] = c1.can_hunt(c2)
        return snapshot
```

### Phase 3: Parallel Execution

```python
from concurrent.futures import ThreadPoolExecutor
import os

class CreatureManager:
    def __init__(self, ...):
        self.n_workers = int(os.environ.get('HERBIE_WORKERS', '4'))
        self.use_multicore = os.environ.get('HERBIE_MULTICORE', '1') == '1'
    
    def step_all(self, ...):
        if self.use_multicore and len(self.creatures) > 10:
            return self._step_all_parallel(...)
        else:
            return self._step_all_sequential(...)
    
    def _step_all_parallel(self, audio_amp, silence_frames, audio_system, step):
        # 1. Create snapshot
        snapshot = WorldSnapshot.from_creatures(self.creatures)
        
        # 2. Parallel step
        alive_creatures = [c for c in self.creatures if c.alive]
        
        def step_one(creature):
            try:
                return creature.step_with_snapshot(snapshot, audio_amp, 
                                                    silence_frames, audio_system)
            except Exception as e:
                print(f"[Error] Creature {creature.creature_id}: {e}")
                return None
        
        with ThreadPoolExecutor(max_workers=self.n_workers) as executor:
            results = list(executor.map(step_one, alive_creatures))
        
        # 3. Process results (sequential)
        dead = []
        reproducing = []
        for creature, result in zip(alive_creatures, results):
            if result == 'dead':
                dead.append(creature)
            elif result == 'reproduce':
                reproducing.append(creature)
        
        # Handle deaths and reproduction (must be sequential)
        for creature in dead:
            self._handle_death(creature)
        for creature in reproducing:
            self._handle_reproduction(creature, step)
```

## Performance Expectations

| Creatures | Sequential | 4 Workers | Speedup |
|-----------|-----------|-----------|---------|
| 20        | 100%      | ~90%      | 0.9x (overhead) |
| 50        | 100%      | ~45%      | 2.2x |
| 100       | 100%      | ~30%      | 3.3x |
| 200       | 100%      | ~28%      | 3.6x |

Overhead is snapshot creation + thread coordination.
Sweet spot is 50-200 creatures with 4 workers.

## Fallback & Safety

```bash
# Disable multicore if issues
export HERBIE_MULTICORE=0

# Adjust worker count
export HERBIE_WORKERS=2
```

## GIL Consideration

Python's GIL means true parallelism only for:
- NumPy operations (release GIL)
- I/O operations

The NLSE evolution is NumPy-heavy, so we should see real speedup.
If not, we can use `multiprocessing` instead (but more complex).

## Testing Plan

1. Run same seed with multicore ON vs OFF
2. Compare final state after 1000 steps
3. Should be identical (deterministic if we seed properly)

## Risk Assessment

**Low Risk:**
- Snapshot approach is read-only safe
- Results collected, processed sequentially
- Deaths/births handled after all steps complete

**Medium Risk:**
- Thread overhead might negate gains for small populations
- GIL might limit actual parallelism

**Mitigation:**
- Auto-disable multicore for < 15 creatures
- Profile and tune worker count
- Easy fallback to sequential
