# V2.1.0 Development Plan: Mendelian Genetics + Multicore

## Overview

V2.1.0 has two major goals:
1. **Wire the existing Mendelian genetics system to actual reproduction**
2. **Implement multicore creature stepping** (without breaking anything)

### Philosophy
- **Epigenetics should be emergent** - we track, not hardcode
- **Generational trauma already exists** - via wavefunction initialization from stressed parents
- **Development is not deterministic** - genotype → phenotype mapping is influenced by environment

---

## Part 1: Mendelian Genetics Integration

### Current State

**Two genome systems exist:**

1. `genetics.py` - Full Mendelian system (656 lines, NOT CONNECTED):
   - 4 chromosomes with linked genes
   - 12 genes across 4 categories (metabolism, locomotion, sensory, social)
   - Dominance types (complete, incomplete, codominant)
   - Meiosis with crossing over
   - Hardy-Weinberg statistics
   - Punnett square predictions

2. `HerbieGenome` in `herbie_social.py` - Simple continuous traits (CURRENTLY USED):
   - 10 continuous traits
   - Random mixing (coin flip per trait)
   - Gaussian mutation

### Integration Strategy

**Don't replace—augment.** HerbieGenome becomes a phenotype layer over Mendelian genotype.

```python
class HerbieGenome:
    # The Mendelian genotype (discrete alleles)
    mendelian: Genome  # From genetics.py
    
    # Phenotype cache (computed from genotype + development)
    _phenotypes: Dict[str, float]
    
    # Development modifiers (NOT GENETIC - emerge from environment)
    _development_context: DevelopmentContext
```

### Phenotype Mapping

Each HerbieGenome trait maps to Mendelian genes:

| HerbieGenome Trait | Mendelian Gene(s) | Mapping |
|-------------------|-------------------|---------|
| body_scale | metabolism_base, energy_storage | 0.8 + 0.2*(M + E) |
| speed_modifier | speed_base, endurance | weighted combo |
| energy_efficiency | energy_storage, metabolism_base | inverse relationship |
| aggression | aggression | direct |
| curiosity | vision_range, hearing_range | sensory → exploration |
| sociability | sociability, parental_care | combo |
| audio_sensitivity | hearing_range | direct |
| grip_strength | agility | mapped |

### Key Functions to Implement

```python
# In herbie_social.py
class HerbieGenome:
    @classmethod
    def from_parents(cls, parent1: 'HerbieGenome', parent2: 'HerbieGenome',
                     development_context: DevelopmentContext = None) -> 'HerbieGenome':
        """
        Sexual reproduction using Mendelian genetics.
        
        1. Call genetics.reproduce() to get child's Mendelian genome
        2. Compute phenotypes from genotype
        3. Apply development context (environment, stress, audio history)
        4. Return phenotypically-expressed HerbieGenome
        """
        from .genetics import reproduce
        
        # Mendelian reproduction
        child_mendelian = reproduce(parent1.mendelian, parent2.mendelian)
        
        # Create child genome
        child = cls()
        child.mendelian = child_mendelian
        
        # Compute base phenotypes from genotype
        child._compute_phenotypes()
        
        # Apply development context (EMERGENT epigenetics)
        if development_context:
            child._apply_development(development_context)
        
        return child
    
    def _compute_phenotypes(self):
        """Convert Mendelian genotype to continuous phenotype values."""
        m = self.mendelian
        
        # Each phenotype is derived from one or more genes
        self.body_scale = 0.8 + 0.15 * m.get_phenotype('metabolism_base') + \
                          0.1 * m.get_phenotype('energy_storage')
        
        self.speed_modifier = 0.6 + 0.3 * m.get_phenotype('speed_base') + \
                              0.15 * m.get_phenotype('agility')
        
        # ... etc for all traits
```

### Development Context (Emergent Epigenetics)

```python
@dataclass
class DevelopmentContext:
    """
    Environmental factors during gestation/development.
    These modify phenotype WITHOUT changing genotype.
    
    NOT HARDCODED - captured from actual simulation state.
    """
    # Mother's state at conception
    mother_energy: float
    mother_stress: float  # skeleton RMS average during pregnancy
    mother_hunger: float
    mother_dream_depth: float  # How much dreaming during gestation
    
    # Environmental
    audio_exposure: float  # Average audio amplitude during development
    season_at_birth: str
    time_of_day_at_birth: float
    
    # Social
    n_nearby_herbies: int  # Crowding stress
    predator_exposure: float
```

### Tracking Genotype vs Phenotype

```python
@dataclass
class GeneticRecord:
    """Full record for data analysis."""
    creature_id: str
    generation: int
    
    # Genotype (what genes say)
    genotype: Dict[str, str]  # {'metabolism_base': 'Mm', 'speed_base': 'SS', ...}
    
    # Phenotype (what expressed)
    phenotype: Dict[str, float]  # {'body_scale': 1.05, 'speed_modifier': 1.2, ...}
    
    # Development context
    development: DevelopmentContext
    
    # Life outcomes (for correlation analysis)
    lifespan: int = 0
    offspring_count: int = 0
    food_gathered: float = 0
    distance_traveled: float = 0
```

### Visualization

New 'D' key for DNA view showing:
```
┌─────────────────────────────────────────────────────────────────┐
│  GENETICS: Ivy (Gen 7)                                          │
├─────────────────────────────────────────────────────────────────┤
│  GENOTYPE                    PHENOTYPE                          │
│  ─────────                   ─────────                          │
│  metabolism_base:  Mm        body_scale:     1.05 (●●●●●○)      │
│  energy_storage:   EE        speed_modifier: 1.23 (●●●●●●●)     │
│  speed_base:       Ss        efficiency:     0.98 (●●●●●)       │
│  agility:          AA        aggression:     0.42 (●●●○)        │
│  sociability:      Cc        sociability:    0.65 (●●●●●)       │
│  aggression:       Gg        audio_sens:     1.67 (●●●●●●●●)    │
│                                                                  │
│  CHROMOSOMES                                                     │
│  ══════════                                                      │
│  0: ─M──E──H─  ─m──E──h─                                        │
│  1: ─S──N──A─  ─s──n──A─                                        │
│  2: ─V──O──R─  ─v──o──r─                                        │
│  3: ─C──G──P─  ─c──g──P─                                        │
│                                                                  │
│  DEVELOPMENT MODIFIERS                                           │
│  ─────────────────────                                          │
│  Mother stress:    0.23 → -0.02 body_scale                      │
│  Audio exposure:   0.87 → +0.15 audio_sens                      │
│  Winter birth:          → -0.05 speed                           │
│                                                                  │
│  HARDY-WEINBERG: Population in equilibrium (χ² = 2.1)           │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 2: Multicore Implementation

### Analysis

The main step loop in `creature_manager.py` (line 743):
```python
for creature in self.creatures[:]:
    result = creature.step(self.creatures, audio_amp, ...)
```

**What `creature.step()` reads:**
- `self.creatures` (for sensing nearby creatures)
- Global audio_amp, silence_frames
- Its own internal state

**What `creature.step()` writes:**
- Only its own internal state
- Returns 'dead' or 'reproduce' (doesn't mutate shared state)

### Thread Safety

The main concern is **collision detection** in `creature.step()`:
- Reads other creatures' positions
- Must not see half-updated positions

Solution: **Double-buffered positions**

```python
class Creature:
    pos: np.ndarray       # Current position (read during step)
    _next_pos: np.ndarray # Next position (written during step)
    
    def finalize_step(self):
        """Called after all parallel steps complete."""
        self.pos = self._next_pos.copy()
```

### Implementation Strategy

**Phase 1: Prepare (no behavior change)**
```python
# Add to Creature
def step(self, ...):
    # ... existing logic ...
    # At end, store next position
    self._next_pos = self.pos.copy()  # Will be updated
    
def finalize_step(self):
    self.pos = self._next_pos
```

**Phase 2: Parallel execution**
```python
from concurrent.futures import ThreadPoolExecutor

def step_all(self, ...):
    # Create position snapshot
    for c in self.creatures:
        c._pos_snapshot = c.pos.copy()
    
    # Parallel step (creatures read from snapshots)
    with ThreadPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(
            lambda c: c.step(self.creatures, audio_amp, ...),
            [c for c in self.creatures if c.alive]
        ))
    
    # Sequential finalization
    for c in self.creatures:
        c.finalize_step()
```

### Performance Expectations

- Current: ~25-30 FPS with 50 creatures
- Target: ~40-50 FPS with 50 creatures
- Scaling: Linear with cores up to creature count

### Fallback

If threading causes issues, use `multiprocessing.Pool` with pickle-free data passing:
```python
# Only pass positions and return deltas
def step_creature_isolated(creature_state, world_snapshot):
    # Pure function, no shared state
    return new_creature_state
```

---

## Implementation Order

### Phase 1: Genetics (V2.1.0a)
1. Add `DevelopmentContext` dataclass
2. Add `mendelian` field to `HerbieGenome`
3. Implement `HerbieGenome.from_parents()` using `genetics.reproduce()`
4. Wire into `attempt_conception()` in herbie.py
5. Add `GeneticRecord` tracking
6. Add 'D' key visualization

### Phase 2: Multicore Prep (V2.1.0b)
1. Add `_pos_snapshot` to Creature
2. Add `finalize_step()` method
3. Modify step to use snapshots for collision
4. Test: same behavior, single-threaded

### Phase 3: Parallel Execution (V2.1.0c)
1. Add ThreadPoolExecutor in step_all
2. Profile and tune worker count
3. Add toggle: `--single-thread` flag
4. Stress test with 100+ creatures

---

## Data Collection

New file: `herbie_world/data/genetic_records.jsonl`

Each line:
```json
{
  "creature_id": "abc123",
  "generation": 7,
  "genotype": {"metabolism_base": "Mm", "speed_base": "SS", ...},
  "phenotype": {"body_scale": 1.05, "speed_modifier": 1.23, ...},
  "development": {"mother_stress": 0.23, "audio_exposure": 0.87, ...},
  "lifespan": 4523,
  "offspring_count": 3,
  "cause_of_death": "starvation"
}
```

---

## Not Implementing (Intentionally)

- **Hardcoded epigenetic rules** - Let them emerge
- **Generational trauma mechanics** - Already happens via wavefunction
- **Predetermined development** - Environment shapes expression
- **Gene expression regulation** - The NLSE IS the regulation

The simulation already has epigenetics: a stressed mother's wavefunction state affects how she initializes her offspring's torus brain. We just need to TRACK it, not CREATE it.
